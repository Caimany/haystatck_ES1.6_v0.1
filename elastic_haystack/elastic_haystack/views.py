# -*- coding: UTF-8 -*-from haystack.views import FacetedSearchView,SearchViewimport simplejson as jsonfrom django.http import HttpResponsefrom haystack.query import SearchQuerySetfrom django.shortcuts import render_to_responseimport requestsdef autocomplete(request):    # sqs = SearchQuerySet().autocomplete(content_auto="fault")    sqs = SearchQuerySet().autocomplete(content_auto=request.GET.get('q', ''))[:5]    suggestions = [result.content_auto for result in sqs]    # Make sure you return a JSON object, not a bare list.    # Otherwise, you could be vulnerable to an XSS attack.    the_data = json.dumps({        'results': suggestions,    })    return HttpResponse(the_data, content_type='application/json')def suggest(request):    # sqs = SearchQuerySet().autocomplete(content_auto="fault")    # sqs = SearchQuerySet().autocomplete(content_auto=request.GET.get('q', ''))[:5]    sqs = SearchQuerySet().auto_query(request.GET.get('q', ''))    sug_sqs = sqs.spelling_suggestion()    # suggestions = [result.content_auto for result in sug_sqs]    suggestions = [sug_sqs]    # Make sure you return a JSON object, not a bare list.    # Otherwise, you could be vulnerable to an XSS attack.    the_data = json.dumps({        'suggestion': suggestions,    })    return HttpResponse(the_data, content_type='application/json')class MyFacetedSearchView(SearchView):    token_url = "http://localhost:9200/elastic-data1/_analyze"    def elastic_token(self, url, data):        if data:            data = data.encode("utf-8")            strtoken = requests.post(url, data).content            dic_strtoken = json.loads(strtoken)            list_strtoken = dic_strtoken["tokens"]                        list_len = len(list_strtoken)            # print(list_len)            strtoken_all = ''            for i in range(list_len):                dic = list_strtoken[i]                strtoken_all = dic["token"] + ' ' + strtoken_all            return strtoken_all.rstrip()        else:            return None    def create_response(self):        (paginator, page) = self.build_page()        context = {            'query': self.query,            'urlquery': self.query,            'form': self.form,            'page': page,            'paginator': paginator,            'suggestion': None,            'count': self.results.count(),            # 'page_count':self.results.count()/20,            'page_count':(self.results.count()/self.results_per_page+1 if self.results.count()%self.results_per_page \                              else self.results.count()/self.results_per_page),            # 'split_query1': split_query,            # 'professionlist': ["服装","鞋包配饰","运动户外","珠宝手表","数码","家电","美容护发","母婴用品","家居建材","美食特产","日用百货","汽车","车品","文化玩乐","旅游","综合","电子商务服务","其他","酒类"],        }        if self.results and hasattr(self.results, 'query') and self.results.query.backend.include_spelling:            context['suggestion'] = self.form.get_suggestion()        context.update(self.extra_context())        return render_to_response(self.template, context, content_type="text/xml;charset=utf-8")class CustomSearchView(SearchView):    def create_response(self):        super(CustomSearchView,self).create_response()        """        Generates the actual HttpResponse to send back to the user.        """        (paginator, page) = self.build_page()        context = {            'query': self.query,            'urlquery': self.query,            'form': self.form,            'page': page,            'paginator': paginator,            'suggestion': None,            'count': self.results.count(),            # 'page_count':self.results.count()/20,            'page_count':(self.results.count()/self.results_per_page+1 if self.results.count()%self.results_per_page \                              else self.results.count()/self.results_per_page),}        if self.results and hasattr(self.results, 'query') and self.results.query.backend.include_spelling:            context['suggestion'] = self.form.get_suggestion()        context.update(self.extra_context())        return render_to_response(self.template, context,content_type="text/xml;charset=utf-8", \                                  # context_instance=self.context_class(self.request))                                  )